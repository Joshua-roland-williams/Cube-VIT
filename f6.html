<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cubing Club Constellation</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      background-color: #0a0a1a;
      color: #fff;
      overflow: hidden;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }
    
    .header {
      padding: 2rem 1.5rem 1.5rem;
      text-align: center;
      background: linear-gradient(to bottom, rgba(0,0,0,0.7) 0%, rgba(0,0,0,0) 100%);
      position: relative;
      z-index: 10;
    }
    
    .header h1 {
      font-size: 2.5rem;
      font-weight: 700;
      background: linear-gradient(135deg, #ffd700 0%, #ffaa00 100%);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      margin-bottom: 0.5rem;
      letter-spacing: -0.5px;
    }
    
    .header p {
      font-size: 1.1rem;
      color: rgba(255,255,255,0.8);
      max-width: 800px;
      margin: 0 auto;
      line-height: 1.5;
    }

    .month-navigation {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1rem;
      position: fixed;
      top: 50%;
      left: 0;
      right: 0;
      transform: translateY(-50%);
      pointer-events: none;
      z-index: 20;
    }

    .month-title-container {
      text-align: center;
      margin-bottom: 1rem;
      position: relative;
      z-index: 10;
      padding: 0 1rem;
    }

    .month-title {
      display: inline-block;
      font-size: 1.8rem;
      font-weight: 600;
      color: #ffd700;
      background: rgba(0,0,0,0.3);
      padding: 0.5rem 1.5rem;
      border-radius: 50px;
      backdrop-filter: blur(10px);
      box-shadow: 0 4px 15px rgba(0,0,0,0.2);
      border: 1px solid rgba(255,215,0,0.2);
    }

    .nav-button {
      background: rgba(255,215,0,0.1);
      border: none;
      color: #ffd700;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      display: flex;
      justify-content: center;
      align-items: center;
      cursor: pointer;
      transition: all 0.3s ease;
      font-size: 1.5rem;
      backdrop-filter: blur(5px);
      pointer-events: all;
      box-shadow: 0 4px 15px rgba(0,0,0,0.2);
      border: 1px solid rgba(255,215,0,0.2);
      position: relative;
      overflow: hidden;
    }

    .nav-button::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, rgba(255,215,0,0.2) 0%, rgba(255,215,0,0) 100%);
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .nav-button:hover {
      transform: scale(1.1);
      background: rgba(255,215,0,0.2);
    }

    .nav-button:hover::after {
      opacity: 1;
    }

    .nav-button:active {
      transform: scale(0.95);
    }

    .nav-button:disabled {
      opacity: 0.3;
      cursor: not-allowed;
      transform: none !important;
    }
    
    .constellation-container {
      position: relative;
      flex-grow: 1;
      overflow: hidden;
    }
    
    #starfield {
      position: absolute;
      width: 100%;
      height: 100%;
    }
    
    .star {
      position: absolute;
      background-color: #ffde7d;
      border-radius: 50%;
      cursor: pointer;
      transition: transform 0.3s ease, box-shadow 0.3s ease;
      z-index: 2;
    }
    
    .star::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 300%;
      height: 300%;
      transform: translate(-50%, -50%);
      border-radius: 50%;
      background: radial-gradient(circle, rgba(255,215,0,0.4) 0%, rgba(255,215,0,0) 70%);
      z-index: -1;
      opacity: 0;
      transition: opacity 0.3s ease;
    }
    
    .star:hover {
      transform: scale(1.5);
      box-shadow: 0 0 20px #ffd700, 0 0 40px #ffd700;
      z-index: 3;
    }
    
    .star:hover::before {
      opacity: 1;
    }
    
    .star-event {
      position: absolute;
      background-color: rgba(10, 10, 30, 0.95);
      border: 1px solid rgba(255,215,0,0.3);
      border-radius: 12px;
      padding: 1rem;
      max-width: 280px;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s ease, visibility 0.3s ease, transform 0.3s ease;
      z-index: 5;
      backdrop-filter: blur(10px);
      box-shadow: 0 10px 25px rgba(0,0,0,0.3);
      pointer-events: none;
      transform: translateY(10px);
    }
    
    .star-event h3 {
      color: #ffd700;
      margin-bottom: 0.5rem;
      font-size: 1.2rem;
      font-weight: 600;
    }
    
    .star-event p {
      color: rgba(255,255,255,0.8);
      font-size: 0.9rem;
      line-height: 1.5;
    }

    .star:hover + .star-event {
      opacity: 1;
      visibility: visible;
      transform: translateY(0);
    }
    
    .constellation-line {
      position: absolute;
      background: linear-gradient(90deg, rgba(255,215,0,0.3) 0%, rgba(255,215,0,0) 100%);
      z-index: 1;
      transform-origin: left center;
      transition: all 0.5s ease;
      height: 2px;
    }
    
    .constellation-line.active {
      background: linear-gradient(90deg, rgba(255,215,0,0.8) 0%, rgba(255,215,0,0.3) 100%);
    }
    
    .modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.9);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 100;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s ease, visibility 0.3s ease;
      backdrop-filter: blur(5px);
    }
    
    .modal.active {
      opacity: 1;
      visibility: visible;
    }
    
    .modal-content {
      background: linear-gradient(145deg, #121236 0%, #0a0a1a 100%);
      border: 1px solid rgba(255,215,0,0.2);
      border-radius: 16px;
      width: 90%;
      max-width: 700px;
      max-height: 85vh;
      overflow-y: auto;
      padding: 2rem;
      position: relative;
      box-shadow: 0 20px 40px rgba(0,0,0,0.5);
      transform: translateY(20px);
      opacity: 0;
      transition: transform 0.3s ease, opacity 0.3s ease;
    }
    
    .modal.active .modal-content {
      transform: translateY(0);
      opacity: 1;
    }
    
    .close-modal {
      position: absolute;
      top: 1rem;
      right: 1rem;
      width: 40px;
      height: 40px;
      background-color: rgba(255,215,0,0.1);
      border: 1px solid rgba(255,215,0,0.2);
      border-radius: 50%;
      color: #ffd700;
      font-size: 1.5rem;
      cursor: pointer;
      display: flex;
      justify-content: center;
      align-items: center;
      transition: all 0.3s ease;
      backdrop-filter: blur(5px);
    }
    
    .close-modal:hover {
      background-color: rgba(255,215,0,0.2);
      transform: rotate(90deg);
    }
    
    .event-header {
      display: flex;
      align-items: center;
      margin-bottom: 1.5rem;
      padding-bottom: 1.5rem;
      border-bottom: 1px solid rgba(255,215,0,0.1);
    }
    
    .event-icon {
      width: 60px;
      height: 60px;
      border-radius: 50%;
      background: linear-gradient(135deg, rgba(255,215,0,0.2) 0%, rgba(255,215,0,0.4) 100%);
      display: flex;
      justify-content: center;
      align-items: center;
      margin-right: 1.5rem;
      flex-shrink: 0;
      box-shadow: 0 5px 15px rgba(255,215,0,0.2);
      border: 1px solid rgba(255,215,0,0.3);
    }
    
    .event-title {
      flex-grow: 1;
    }
    
    .event-title h2 {
      color: #ffd700;
      font-size: 1.8rem;
      margin-bottom: 0.5rem;
      font-weight: 600;
    }
    
    .event-title p {
      color: rgba(255,255,255,0.7);
      font-size: 1rem;
    }
    
    .event-body {
      margin-bottom: 2rem;
      line-height: 1.7;
      color: rgba(255,255,255,0.9);
    }
    
    .event-body p {
      margin-bottom: 1rem;
    }
    
    .event-gallery {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
      gap: 1rem;
      margin-top: 2rem;
    }
    
    .gallery-item {
      height: 120px;
      background-color: rgba(28,28,66,0.5);
      border-radius: 8px;
      overflow: hidden;
      transition: transform 0.3s ease;
      position: relative;
      border: 1px solid rgba(255,215,0,0.1);
    }
    
    .gallery-item img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      transition: transform 0.5s ease;
    }
    
    .gallery-item:hover {
      transform: translateY(-5px);
      box-shadow: 0 10px 20px rgba(0,0,0,0.3);
    }
    
    .gallery-item:hover img {
      transform: scale(1.05);
    }

    .no-images {
      grid-column: 1 / -1;
      text-align: center;
      padding: 2rem;
      color: rgba(255,255,255,0.5);
      font-style: italic;
      display: none;
    }

    .no-images.visible {
      display: block;
    }
    
    @media (max-width: 768px) {
      .header h1 {
        font-size: 2rem;
      }
      
      .header p {
        font-size: 1rem;
      }
      
      .month-title {
        font-size: 1.4rem;
      }

      .nav-button {
        width: 45px;
        height: 45px;
        font-size: 1.3rem;
      }
      
      .modal-content {
        width: 95%;
        padding: 1.5rem;
      }
      
      .event-title h2 {
        font-size: 1.5rem;
      }

      .event-header {
        flex-direction: column;
        align-items: flex-start;
      }

      .event-icon {
        margin-right: 0;
        margin-bottom: 1rem;
      }
      
      .event-gallery {
        grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
      }
    }
    
    .shooting-star {
      position: absolute;
      width: 2px;
      height: 2px;
      background: linear-gradient(to right, rgba(255, 255, 255, 0), #fff 50%, rgba(255, 255, 255, 0));
      animation: shooting 4s linear infinite;
      opacity: 0;
      z-index: 1;
    }
    
    @keyframes shooting {
      0% {
        transform: translateX(0) translateY(0) rotate(var(--angle));
        opacity: 0;
      }
      10% {
        opacity: 1;
      }
      80% {
        opacity: 1;
      }
      100% {
        transform: translateX(var(--end-x)) translateY(var(--end-y)) rotate(var(--angle));
        opacity: 0;
      }
    }
    
    .twinkle {
      animation: twinkle var(--duration) ease-in-out infinite;
      animation-delay: var(--delay);
    }
    
    @keyframes twinkle {
      0%, 100% {
        opacity: 0.3;
        transform: scale(1);
      }
      50% {
        opacity: 1;
        transform: scale(1.2);
      }
    }

    /* Loading spinner */
    .loader {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      backdrop-filter: blur(5px);
    }

    .spinner {
      width: 50px;
      height: 50px;
      border: 4px solid rgba(255, 215, 0, 0.1);
      border-radius: 50%;
      border-top-color: #ffd700;
      animation: spin 1s ease-in-out infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .cubing-icon {
      width: 30px;
      height: 30px;
      fill: #121236;
    }

    /* Scrollbar styling */
    ::-webkit-scrollbar {
      width: 8px;
    }

    ::-webkit-scrollbar-track {
      background: rgba(255,215,0,0.1);
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb {
      background: rgba(255,215,0,0.3);
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: rgba(255,215,0,0.5);
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>Cubing Club Constellation</h1>
    <p>Explore our events across the year. Hover over stars to preview, click for details.</p>
  </div>

  <div class="month-title-container">
    <div class="month-title" id="monthTitle">Loading...</div>
  </div>

  <div class="month-navigation">
    <button class="nav-button" id="prevMonth">←</button>
    <button class="nav-button" id="nextMonth">→</button>
  </div>
  
  <div class="constellation-container">
    <div id="starfield"></div>
  </div>
  
  <div class="modal" id="eventModal">
    <div class="modal-content">
      <button class="close-modal" id="closeModal">×</button>
      <div class="event-header">
        <div class="event-icon">
          <svg class="cubing-icon" viewBox="0 0 24 24">
            <path d="M12 2L15.09 8.26L22 9.27L17 14.14L18.18 21.02L12 17.77L5.82 21.02L7 14.14L2 9.27L8.91 8.26L12 2Z"></path>
          </svg>
        </div>
        <div class="event-title">
          <h2 id="modalTitle">Event Title</h2>
          <p id="modalDate">Event Date</p>
        </div>
      </div>
      <div class="event-body" id="modalDescription">
        <p>Detailed event description will appear here.</p>
      </div>
      <div class="event-gallery" id="modalGallery">
        <div class="no-images">No images available for this event</div>
      </div>
    </div>
  </div>

  <div class="loader" id="loader">
    <div class="spinner"></div>
  </div>
<script>
    // Global variables
let allEvents = {};
let currentMonthYear = '';
let availableMonths = [];
let isLoading = false;
let shootingStars = [];
let scrollTimeout = null;

// Predefined constellation patterns for different numbers of events
const constellationPatterns = {
  1: [{ x: 50, y: 50 }],
  2: [
    { x: 40, y: 45 },
    { x: 60, y: 55 }
  ],
  3: [
    { x: 50, y: 30 },
    { x: 35, y: 60 },
    { x: 65, y: 60 }
  ],
  4: [
    { x: 40, y: 35 },
    { x: 60, y: 35 },
    { x: 35, y: 65 },
    { x: 65, y: 65 }
  ],
  5: [
    { x: 50, y: 25 },
    { x: 70, y: 40 },
    { x: 65, y: 70 },
    { x: 35, y: 70 },
    { x: 30, y: 40 }
  ],
  6: [
    { x: 35, y: 30 },
    { x: 65, y: 30 },
    { x: 75, y: 50 },
    { x: 60, y: 75 },
    { x: 40, y: 75 },
    { x: 25, y: 50 }
  ],
  7: [
    { x: 50, y: 20 },
    { x: 70, y: 35 },
    { x: 75, y: 60 },
    { x: 55, y: 80 },
    { x: 45, y: 80 },
    { x: 25, y: 60 },
    { x: 30, y: 35 }
  ],
  8: [
    { x: 50, y: 15 },
    { x: 75, y: 25 },
    { x: 85, y: 50 },
    { x: 75, y: 75 },
    { x: 50, y: 85 },
    { x: 25, y: 75 },
    { x: 15, y: 50 },
    { x: 25, y: 25 }
  ]
};

// Better connection patterns - only outline connections, no intersections
const connectionPatterns = {
  1: [],
  2: [[0, 1]],
  3: [[0, 1], [1, 2], [2, 0]], // Triangle outline
  4: [[0, 1], [1, 3], [3, 2], [2, 0]], // Rectangle outline
  5: [[0, 1], [1, 2], [2, 3], [3, 4], [4, 0]], // Pentagon outline
  6: [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5], [5, 0]], // Hexagon outline
  7: [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 0]], // Heptagon outline
  8: [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7], [7, 0]] // Octagon outline
};

// Helper function to parse month-year string to Date object
function parseMonthYear(monthYearStr) {
  try {
    const parts = monthYearStr.trim().split(' ');
    if (parts.length !== 2) return null;
    
    const [monthName, yearStr] = parts;
    const year = parseInt(yearStr);
    if (isNaN(year)) return null;
    
    const monthNames = [
      'January', 'February', 'March', 'April', 'May', 'June',
      'July', 'August', 'September', 'October', 'November', 'December'
    ];
    
    const monthIndex = monthNames.indexOf(monthName);
    if (monthIndex === -1) return null;
    
    return new Date(year, monthIndex, 1);
  } catch (error) {
    console.error('Error parsing month-year:', monthYearStr, error);
    return null;
  }
}

// Helper function to format Date to month-year string
function formatMonthYear(date) {
  return date.toLocaleString('default', { month: 'long', year: 'numeric' });
}

// FIXED: Get next month that has events
function getNextMonthWithEvents(fromMonth) {
  const fromDate = parseMonthYear(fromMonth);
  if (!fromDate) return null;
  
  const nextMonth = new Date(fromDate.getFullYear(), fromDate.getMonth() + 1, 1);
  const maxDate = new Date(fromDate.getFullYear() + 2, fromDate.getMonth(), 1); // Look up to 2 years ahead
  
  while (nextMonth <= maxDate) {
    const monthStr = formatMonthYear(nextMonth);
    if (allEvents[monthStr] && allEvents[monthStr].length > 0) {
      return monthStr;
    }
    nextMonth.setMonth(nextMonth.getMonth() + 1);
  }
  
  return null;
}

// FIXED: Get previous month that has events
function getPrevMonthWithEvents(fromMonth) {
  const fromDate = parseMonthYear(fromMonth);
  if (!fromDate) return null;
  
  const prevMonth = new Date(fromDate.getFullYear(), fromDate.getMonth() - 1, 1);
  const minDate = new Date(fromDate.getFullYear() - 2, fromDate.getMonth(), 1); // Look up to 2 years back
  
  while (prevMonth >= minDate) {
    const monthStr = formatMonthYear(prevMonth);
    if (allEvents[monthStr] && allEvents[monthStr].length > 0) {
      return monthStr;
    }
    prevMonth.setMonth(prevMonth.getMonth() - 1);
  }
  
  return null;
}

document.addEventListener('DOMContentLoaded', function() {
  const starfield = document.getElementById('starfield');
  const modal = document.getElementById('eventModal');
  const closeModal = document.getElementById('closeModal');
  const modalTitle = document.getElementById('modalTitle');
  const modalDate = document.getElementById('modalDate');
  const modalDescription = document.getElementById('modalDescription');
  const modalGallery = document.getElementById('modalGallery');
  const prevMonthBtn = document.getElementById('prevMonth');
  const nextMonthBtn = document.getElementById('nextMonth');
  const monthTitle = document.getElementById('monthTitle');
  const loader = document.getElementById('loader');
  const noImagesPlaceholder = document.querySelector('.no-images');

  // Load events data
  loadEventsData();

  // Event listeners
  closeModal.addEventListener('click', function() {
    modal.classList.remove('active');
  });

  prevMonthBtn.addEventListener('click', function() {
    if (isLoading) return;
    navigateMonth(-1);
  });

  nextMonthBtn.addEventListener('click', function() {
    if (isLoading) return;
    navigateMonth(1);
  });

  // Handle keyboard arrow keys for month navigation
  document.addEventListener('keydown', function(e) {
    if (isLoading) return;
    if (e.key === 'ArrowLeft') {
      navigateMonth(-1);
    } else if (e.key === 'ArrowRight') {
      navigateMonth(1);
    }
  });

  // Handle mouse wheel for month navigation with debounce
  window.addEventListener('wheel', function(e) {
    if (isLoading) return;
    
    if (scrollTimeout) {
      clearTimeout(scrollTimeout);
    }
    
    scrollTimeout = setTimeout(() => {
      if (e.deltaY > 30) {
        navigateMonth(1);
      } else if (e.deltaY < -30) {
        navigateMonth(-1);
      }
    }, 100);
  }, { passive: true });

  // Load events data from JSON file
  async function loadEventsData() {
    try {
      isLoading = true;
      loader.style.display = 'flex';
      
      const response = await fetch('events.json');
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      allEvents = await response.json();
      
      // FIXED: Always start with current month
      setInitialMonth();
      
      // Update UI
      updateMonthDisplay();
      renderConstellation();
      startShootingStars();
    } catch (error) {
      console.error('Error loading events data:', error);
      monthTitle.textContent = 'Error loading events - Check if events.json exists';
      
      starfield.innerHTML = `
        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; color: rgba(255,255,255,0.7);">
          <p>Unable to load events.json</p>
          <p style="font-size: 0.9rem; margin-top: 0.5rem;">Make sure events.json file exists in the same folder</p>
        </div>
      `;
    } finally {
      isLoading = false;
      loader.style.display = 'none';
    }
  }

  // FIXED: Always set initial month to current month
  function setInitialMonth() {
    const now = new Date();
    currentMonthYear = formatMonthYear(now);
  }

  // FIXED: Navigate to months with events only
  function navigateMonth(direction) {
    let targetMonth = null;
    
    if (direction > 0) {
      // Going forward - find next month with events
      targetMonth = getNextMonthWithEvents(currentMonthYear);
    } else {
      // Going backward - find previous month with events
      targetMonth = getPrevMonthWithEvents(currentMonthYear);
    }
    
    if (targetMonth) {
      currentMonthYear = targetMonth;
      updateMonthDisplay();
      renderConstellation();
    }
  }

  // FIXED: Update month display and button states based on event availability
  function updateMonthDisplay() {
    monthTitle.textContent = currentMonthYear || 'No Events Available';
    
    // Check if there are events in next/previous months
    const hasNextEvents = getNextMonthWithEvents(currentMonthYear) !== null;
    const hasPrevEvents = getPrevMonthWithEvents(currentMonthYear) !== null;
    
    nextMonthBtn.disabled = !hasNextEvents;
    prevMonthBtn.disabled = !hasPrevEvents;
  }

  // Render constellation for current month
  function renderConstellation() {
    starfield.innerHTML = '';
    createBackgroundStars();
    
    const currentEvents = allEvents[currentMonthYear] || [];
    
    if (currentEvents.length === 0) {
      const noEventsMsg = document.createElement('div');
      noEventsMsg.style.cssText = `
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        text-align: center;
        color: rgba(255,255,255,0.6);
        font-size: 1.2rem;
      `;
      noEventsMsg.textContent = `No events in ${currentMonthYear}`;
      starfield.appendChild(noEventsMsg);
      return;
    }
    
    const positionedEvents = calculateEventPositions(currentEvents);
    
    positionedEvents.forEach((event, index) => {
      createEventStar(event);
    });
    
    createConstellationConnections(positionedEvents);
  }

  // Create background stars
  function createBackgroundStars() {
    const starCount = 100 + Math.floor(Math.random() * 50);
    
    for (let i = 0; i < starCount; i++) {
      const star = document.createElement('div');
      const size = Math.random() * 2 + 0.5;
      const opacity = Math.random() * 0.7 + 0.3;
      const duration = 3 + Math.random() * 4;
      const delay = Math.random() * 5;
      
      star.classList.add('star', 'twinkle');
      star.style.width = `${size}px`;
      star.style.height = `${size}px`;
      star.style.left = `${Math.random() * 100}%`;
      star.style.top = `${Math.random() * 100}%`;
      star.style.opacity = opacity;
      star.style.setProperty('--duration', `${duration}s`);
      star.style.setProperty('--delay', `${delay}s`);
      
      starfield.appendChild(star);
    }
  }

  // Start shooting stars animation
  function startShootingStars() {
    shootingStars.forEach(star => {
      if (star.element && star.element.parentNode) {
        star.element.remove();
      }
      clearTimeout(star.timeout);
    });
    shootingStars = [];
    
    const starCount = 1 + Math.floor(Math.random() * 2);
    for (let i = 0; i < starCount; i++) {
      createShootingStarWithDelay(i * 3000);
    }
  }

  // Create shooting star with delay
  function createShootingStarWithDelay(delay) {
    const timeout = setTimeout(() => {
      const star = createShootingStar();
      const starData = {
        element: star.element,
        timeout: setTimeout(() => {
          star.element.remove();
          createShootingStarWithDelay(Math.random() * 5000 + 5000);
        }, 4000)
      };
      shootingStars.push(starData);
    }, delay);
    
    shootingStars.push({ timeout });
  }

  // Create a single shooting star
  function createShootingStar() {
    const star = document.createElement('div');
    star.classList.add('shooting-star');
    
    const startX = Math.random() * 100 + 20;
    const startY = Math.random() * 50;
    const angle = 200 + Math.random() * 20;
    const distance = 500 + Math.random() * 300;
    
    const endX = startX - Math.cos(angle * Math.PI / 180) * distance;
    const endY = startY + Math.sin(angle * Math.PI / 180) * distance;
    
    star.style.left = `${startX}%`;
    star.style.top = `${startY}%`;
    star.style.setProperty('--angle', `${angle}deg`);
    star.style.setProperty('--end-x', `-${distance}px`);
    star.style.setProperty('--end-y', `${endY - startY}px`);
    star.style.animationDelay = `${Math.random() * 2}s`;
    
    starfield.appendChild(star);
    
    return { element: star };
  }

  // Calculate positions for events using predefined constellation patterns
  function calculateEventPositions(events) {
    if (events.length === 0) return [];
    
    const eventCount = Math.min(events.length, 8);
    let positions = [];
    
    if (eventCount <= 8 && constellationPatterns[eventCount]) {
      positions = [...constellationPatterns[eventCount]];
    } else {
      positions = generateLargeConstellation(events.length);
    }
    
    positions = positions.map(pos => ({
      x: pos.x + (Math.random() - 0.5) * 8,
      y: pos.y + (Math.random() - 0.5) * 8
    }));
    
    positions = positions.map(pos => ({
      x: Math.max(15, Math.min(85, pos.x)),
      y: Math.max(15, Math.min(85, pos.y))
    }));
    
    return events.map((event, index) => ({
      ...event,
      position: positions[index % positions.length]
    }));
  }

  // Generate constellation pattern for large numbers of events
  function generateLargeConstellation(count) {
    const positions = [];
    const centerX = 50;
    const centerY = 50;
    
    const rings = Math.ceil(count / 8);
    let eventIndex = 0;
    
    for (let ring = 0; ring < rings && eventIndex < count; ring++) {
      const radius = 20 + (ring * 15);
      const eventsInRing = Math.min(8, count - eventIndex);
      const angleStep = (2 * Math.PI) / eventsInRing;
      
      for (let i = 0; i < eventsInRing; i++) {
        const angle = i * angleStep + (ring * 0.5);
        const x = centerX + radius * Math.cos(angle);
        const y = centerY + radius * Math.sin(angle);
        
        positions.push({ x, y });
        eventIndex++;
      }
    }
    
    return positions;
  }

  // Create constellation connections
  function createConstellationConnections(positionedEvents) {
    const eventCount = Math.min(positionedEvents.length, 8);
    let connections = [];
    
    if (eventCount <= 8 && connectionPatterns[eventCount]) {
      connections = connectionPatterns[eventCount];
    } else {
      connections = generateLargeConstellationOutlineConnections(positionedEvents.length);
    }
    
    connections.forEach(([startIdx, endIdx]) => {
      if (startIdx < positionedEvents.length && endIdx < positionedEvents.length) {
        connectStars(positionedEvents[startIdx], positionedEvents[endIdx]);
      }
    });
  }

  // Generate outline connections for large constellations
  function generateLargeConstellationOutlineConnections(count) {
    const connections = [];
    const rings = Math.ceil(count / 8);
    let eventIndex = 0;
    
    for (let ring = 0; ring < rings; ring++) {
      const eventsInRing = Math.min(8, count - eventIndex);
      const ringStart = eventIndex;
      
      for (let i = 0; i < eventsInRing; i++) {
        const current = ringStart + i;
        const next = ringStart + ((i + 1) % eventsInRing);
        connections.push([current, next]);
      }
      
      if (ring < rings - 1) {
        const nextRingStart = eventIndex + eventsInRing;
        const nextRingSize = Math.min(8, count - nextRingStart);
        
        for (let i = 0; i < Math.min(eventsInRing, nextRingSize); i += 2) {
          connections.push([ringStart + i, nextRingStart + (i % nextRingSize)]);
        }
      }
      
      eventIndex += eventsInRing;
    }
    
    return connections;
  }

  // Create event star
  function createEventStar(event) {
    const star = document.createElement('div');
    const starEvent = document.createElement('div');
    const containerWidth = starfield.offsetWidth;
    const containerHeight = starfield.offsetHeight;
    const xPos = (event.position.x / 100) * containerWidth;
    const yPos = (event.position.y / 100) * containerHeight;
    
    star.classList.add('star');
    star.dataset.id = event.id;
    star.style.width = '16px';
    star.style.height = '16px';
    star.style.left = `${xPos}px`;
    star.style.top = `${yPos}px`;
    star.style.boxShadow = '0 0 10px #ffd700, 0 0 20px #ffd700';
    
    starEvent.classList.add('star-event');
    starEvent.innerHTML = `
      <h3>${event.title}</h3>
      <p>${event.date}</p>
      <p>${event.summary}</p>
    `;
    
    const centerX = containerWidth / 2;
    const centerY = containerHeight / 2;
    
    if (xPos > centerX) {
      starEvent.style.right = `${containerWidth - xPos + 20}px`;
      starEvent.style.left = 'auto';
    } else {
      starEvent.style.left = `${xPos + 20}px`;
      starEvent.style.right = 'auto';
    }
    
    if (yPos > centerY) {
      starEvent.style.bottom = `${containerHeight - yPos + 20}px`;
      starEvent.style.top = 'auto';
    } else {
      starEvent.style.top = `${yPos + 20}px`;
      starEvent.style.bottom = 'auto';
    }
    
    star.addEventListener('click', function() {
      openEventModal(event);
    });
    
    starfield.appendChild(star);
    starfield.appendChild(starEvent);
  }

  // Connect stars with lines
  function connectStars(event1, event2) {
    const containerWidth = starfield.offsetWidth;
    const containerHeight = starfield.offsetHeight;
    const x1 = (event1.position.x / 100) * containerWidth + 8;
    const y1 = (event1.position.y / 100) * containerHeight + 8;
    const x2 = (event2.position.x / 100) * containerWidth + 8;
    const y2 = (event2.position.y / 100) * containerHeight + 8;
    
    const line = document.createElement('div');
    line.classList.add('constellation-line');
    
    const length = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
    const angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;
    
    line.style.width = `${length}px`;
    line.style.left = `${x1}px`;
    line.style.top = `${y1}px`;
    line.style.transform = `rotate(${angle}deg)`;
    
    starfield.appendChild(line);
  }

  // Open event modal
  function openEventModal(event) {
    modalTitle.textContent = event.title;
    modalDate.textContent = event.date;
    modalDescription.innerHTML = event.description;
    
    modalGallery.innerHTML = '';
    
    if (event.images && event.images.length > 0) {
      noImagesPlaceholder.classList.remove('visible');
      event.images.forEach(image => {
        const galleryItem = document.createElement('div');
        galleryItem.classList.add('gallery-item');
        galleryItem.innerHTML = `
          <img src="${image}" alt="Event image" loading="lazy">
        `;
        modalGallery.appendChild(galleryItem);
      });
    } else {
      noImagesPlaceholder.classList.add('visible');
      modalGallery.appendChild(noImagesPlaceholder);
    }
    
    modal.classList.add('active');
  }

  // Handle window resize
  window.addEventListener('resize', function() {
    renderConstellation();
  });
});
</script>
</body>
</html>